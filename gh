. .paths
GIT_DIR_STRING=$(git rev-parse --git-dir 2>/dev/null)
if [ "$GIT_DIR_STRING" == "" ];
then
    echo "fatal: Not a git repository";
else
    LINE=$(expr $1 2>/dev/null)
    FILE="$GIT_DIR_STRING/logs/HEAD"

    # old method using sed to get the best match
    #RESULT_STRING=`sed -n 's/^.*from \(\S*\) to.*$/\1/p' $FILE | sed -n "$LINEp" 2>/dev/null` 

    # the second sed command reverses the order. The awk command removes duplicates via associative array.
    RESULT_STRING=`sed -n 's/^.*from \(\S*\) to.*$/\1/p' $FILE | sed '1!G;h;$!d' | awk 'BEGIN {i=0;} { if (!($1 in ar)) { ar[$1]; list[i++]=$1; } } END {for (i = 0; i < length(list); i++) {print list[i]; }  }'` 

    IFS=$'\n' MATCHES=(${RESULT_STRING//$'\n'/ })
    IFS=$'\n' MATCHES=($RESULT_STRING)
    TMP_COUNT=0

    if [ "$1" == "" ];
        then
        if [ "$RESULT_STRING" == "" ];
            then
                echo "No checkout history";
        else
            for RESULT in "${MATCHES[@]}"
            do
                if [ "${TMP_COUNT}" -le 10 ];
                    then
                        echo "${TMP_COUNT}. $RESULT"
                        TMP_COUNT=$(expr $TMP_COUNT + 1)
                fi
            done
        fi
    # elif [ "$1" == "0" ];
        # then
            # git checkout HEAD
    # elif [ "${#MATCHES[@]}" == 1 ];
        # then
            # git checkout "${MATCHES[$LINE]}"
    elif [ "$1" -le "${#MATCHES[@]}" ];
        then 
            git checkout "${MATCHES[$1]}"
    else
        echo "Invalid selection, unable to checkout"
    fi
fi